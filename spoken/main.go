package main

// Файл с устными вопросами

// 1. Какой самый эффективный способ конкатенации строк?

// Для эффективной конкатенации используется strings.Builder. Он позволяет избежать копирования при преобразовании Builder в строку.
// В случае, если заранее известен размер строки, можно использовать метод Grow() для предварительного выделения памяти.

// 2. Что такое интерфейсы, как они применяются в Go?

// Интерфейсы - это контракты. Создавая интерфейс, мы гарантируем, что тип данных, реализующий интерфейс, будет иметь именно такие методы и именно
// с такой сигнатурой. Интерфейсы определяют функицонал, но не реализуют его.
// Интерфейсы позволяют уменьшить связность кода, что особенно актуально при тестировании.

// 3. Чем отличаются RWMutex от Mutex?

// RWMutex - это блокировка взаимного исключения чтения/записи. Блокировка может удерживаться произвольным числом читателем или одним писателем.
// Другими словами, читателям не нужно ждать друг друга. Им нужно только дождаться писателей, которые удерживают блокировку.
// Таким образом, RWMutex предпочтительнее для данных, которые в основном считываются, а ресурс, который сохраняется по сравнению с sync.Mutex - это время.

// 4. Чем отличаются буферизированные и не буферизированные каналы?

// По умолчанию каналы не буферизованы, это означает, что они будут принимать отправления (chan <-), только если есть соответствующий прием (<- chan),
// готовый принять отправленное значение. Буферизованные каналы принимают ограниченное количество значений без соответствующего приемника для этих значений.
// При отправке в небуферизированный канал отправка будет приостановлена, пока не будет прочитано предыдущее сообщение.
// При отправке в буферизированный канал отправка не будет приостановлена, пока канал не заполнится, далее нужно будет ждать, когда сообщение будет прочтено.

// 5. Какой размер у структуры struct{}{}?

// Хотя сама структура и занимает 0 байт, есть накладные расходы на ее объявление, хранение указателя, ссылки и т.п.
// Так что это совсем не 0 байт, но использование struct{} имеет наименьшее потребление памяти.

// 6. Есть ли в Go перегрузка методов или операторов?

// Нет, в Go нет перегрузок методов или операторов.

// 7. В какой последовательности будут выведены элементы map[int]int?
// Пример:
// m[0]=1
// m[1]=124
// m[2]=281

// В Go элементы мапы выводятся в рандомном порядке. https://goplay.space/#K0cQs7DTVQq

// 8. В чем разница make и new?

// типы данных:
// make - slice, map, chan
// new - принимает любой тип данных, включая slice, map, chan
// параметры:
// make - тип данных и размер
// new - только тип, без размера
// возвращаемое значение:
// make - сам тип
// new - указатель
// действия:
// make - выделить место в памяти и инициализировать
// new - выделить место в памяти без инициализации

// 9. Сколько существует способов задать переменную типа slice или map?

// 1. инициализация с использованием литералов:
// emptySlice := []int{} - пустой слайс
// initializedSlice := []int{1, 2, 3} - слайс с начальными значениями
// emptyMap := map[string]int{} - пустая мапа
// мапа с начальными значениями
// initializedMap := map[string]int{
//     "один": 1,
//     "два":  2,
//     "три":  3,
// }
// 2. с использованием make():
// slice := make([]int, 0, 10)
// m := make(map[string]int)
// 3. создание слайса из существующего массива:
// arr := [5]int{1, 2, 3, 4, 5}
// sliceFromArr := arr[1:4]
// 4. с использованием new():
// Создаем указатель на map
// var myMapPtr *map[string]int
// Используем new(), чтобы выделить память для map
// myMapPtr = new(map[string]int)
// Инициализируем map (по-прежнему используя *myMapPtr)
// *myMapPtr = make(map[string]int)
// Теперь мы можем добавлять элементы в карту
// (*myMapPtr)["один"] = 1
// Создаем указатель на slice
// var mySlicePtr *[]int
// Используем new(), чтобы выделить память для slice
// mySlicePtr = new([]int)
// Инициализируем slice (по-прежнему используя *mySlicePtr)
// *mySlicePtr = make([]int, 0, 10)
// Теперь мы можем добавлять элементы в слайс
// *mySlicePtr = append(*mySlicePtr, 1, 2, 3)

// 10. Что выведет данная программа и почему?

// func update(p *int) {
// 	b := 2
// 	p = &b
//   }

//   func main() {
// 	var (
// 	   a = 1
// 	   p = &a
// 	)
// 	fmt.Println(*p)
// 	update(p)
// 	fmt.Println(*p)
//   }

// вывод:
// 1
// 1
// так происходит, потому что update() работает с копией переменной p, а не с оригинальной переменной, созданной в main().
// поэтому вызовы Println() в функции main() выводят 1, ввиду того, что переменная p продолжает ссылаться на а.

// 11. Что выведет данная программа и почему?

// func main() {
// 	wg := sync.WaitGroup{}
// 	for i := 0; i < 5; i++ {
// 	   wg.Add(1)
// 	   go func(wg sync.WaitGroup, i int) {
// 		  fmt.Println(i)
// 		  wg.Done()
// 	   }(wg, i)
// 	}
// 	wg.Wait()
// 	fmt.Println("exit")
//   }

// вывод:
// 4
// 1
// 2
// 3
// 0
// fatal error: all goroutines are asleep - deadlock!

// такое происходит потому, что мы передаем в горутину wg по значению. в итоге каждая горутина работает со своей локальной копией,
// вызывая у нее метод Done(). это не влияет на оригинальную wg, созданную в основной функции.
// чтобы это исправить, необходимо передавать wg по ссылке:
// go func(wg *sync.WaitGroup, i int) {
// 	fmt.Println(i)
// 	wg.Done()
// }(&wg, i)
// в этом случае вывод будет таким:
// 4
// 1
// 2
// 3
// 0
// exit

// 12. Что выведет данная программа и почему?

// func main() {
// 	n := 0
// 	if true {
// 	   n := 1
// 	   n++
// 	}
// 	fmt.Println(n)
//   }

// вывод:
// 0
// программа выводит 0, потому что в блоке if создается новая переменная n, которой присваивается значение 1 и инкрементируется.
// хотя обе переменные названы одинаково, для компьютера это две разные переменные, никак между собой не связанные.
// переменная n, созданная в блоке if, видна только там. вызов же функции Println() происходит вне блока if,
// где существует только первая переменная n, которой присвоено значение 0.

// 13.  Что выведет данная программа и почему?

// func someAction(v []int8, b int8) {
//   v[0] = 100
//   v = append(v, b)
// }

// func main() {
//   var a = []int8{1, 2, 3, 4, 5}
//   someAction(a, 6)
//   fmt.Println(a)
// }

// вывод:
// [100 2 3 4 5]

// мы видим именно такой вывод, потому что в функции someAction() меняем первый элемент слайса. эта операция меняет также и исходный слайс,
// потому что слайс v ссылается на тот же слайс, что и a. далее мы вызываем функцию append, которая создает новый слайс, поэтому
// изменения не влияют на исходный слайс.

// 14. Что выведет данная программа и почему?

// func main() {
// 	slice := []string{"a", "a"}

// 	func(slice []string) {
// 	   slice = append(slice, "a")
// 	   slice[0] = "b"
// 	   slice[1] = "b"
// 	   fmt.Print(slice)
// 	}(slice)
// 	fmt.Print(slice)
//   }

// вывод:
// [b b a][a a]

// первое, что выводит программа - локальная копия слайса в анонимной функции. в ней мы изменили значения слайса, а также добавили новый элемент.
// второй, что выводит программа - изначальный слайс, созданный во внешней функции. он остался неизменным, так как изменения, происходящие в анонимной
// функции, коснулись только локальной копии слайса, переданной в функцию.
